/*------------------------------------------------------------------------------  -----------------
  The MIT License (MIT)

  Copyright (c) 2015-2017 J.Hubert

  Permission is hereby granted, free of charge, to any person obtaining a copy of this software 
  and associated documentation files (the "Software"), 
  to deal in the Software without restriction, including without limitation the rights to use, 
  copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, 
  and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all copies 
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------------------------- */

#include "TOOLS\IMAGER\IMAGER.H"

#include "DEMOSDK\LOAD.H"
#include "DEMOSDK\LOADDEFS.H"

#include <vector>
#include <string>


struct FileEntry
{
	u32	    nbsectors;
	u32     startsector;
	u32     side;
	u32     track;
    s32     metadataIndex;
    u32     padding;
    std::string name;
};

struct FileMetaData
{
	u32			offset;
	u32			size;
	s32			originalsize;
	std::string name;
    std::string filename;
};

static u32 STDswap32(u32 _v)
{
    u32 v;
    u8* s = (u8*) &_v;
    u8* d = (u8*) &v;

    d[0] = s[3];
    d[1] = s[2];
    d[2] = s[1];
    d[3] = s[0];

    return v;
}

static u16 STDswap16(u16 _v)
{
    u16 v;
    u8* s = (u8*) &_v;
    u8* d = (u8*) &v;

    d[0] = s[1];
    d[1] = s[0];
    
    return v;
}


class OutputFile
{
protected:
    FILE*           m_file;
    std::string     m_fileid;
    std::string     m_filename;


    OutputFile(const char* _filename, const char* _ext, const char* _fileid)
        : m_fileid      (_fileid)
        , m_filename    (_filename)
    {
    	char filename[256];
    	
        sprintf(filename, "%s.%s", _filename, _ext);
	    m_file = fopen (filename, "w");
    }
    
    ~OutputFile()
    {
        if (m_file != NULL)
        {
            fclose(m_file);
            m_file = NULL;
        }
    }

public:
    
    bool isValid() const { return m_file != NULL; }
};


class HeaderFile : public OutputFile
{
public:
    HeaderFile (const char* _filename, const char* _fileid) 
        : OutputFile(_filename, "H", _fileid)
  
    {}

    void write(std::vector<FileEntry>& _fileEntries, std::vector<FileMetaData>& _metaData, u32 _mediausedsize)
    {
        assert (m_file != NULL);
        const char* fileid = m_fileid.c_str();

        fprintf (m_file, "/* This file is generated by Imager tool - it is synchronized with FAT data stored into sectors 1 & 2 */\n");

		fprintf (m_file, "#ifndef %s_H\n#define %s_H\n\n#include \"DEMOSDK\\LOAD.H\"\n\n", fileid, fileid);
		fprintf (m_file, "ENUM(RSC_%s_ENTRIES)\n{\n", m_fileid.c_str());

        for (u32 t = 0 ; t < _fileEntries.size() ; t++)
        {
			fprintf (m_file, "    RSC_%s_%s,\n", m_fileid.c_str(), _fileEntries[t].name.c_str() );
        }

		fprintf (m_file, "    RSC_%s_NBENTRIES\n};\n\n", fileid);

		// Files metadata list

		fprintf (m_file, "ENUM(RSC_%s_METADATA)\n{\n", fileid);

		for (std::vector<FileMetaData>::const_iterator metaData = _metaData.begin() ; metaData != _metaData.end() ; metaData++)
		{
			fprintf (m_file, "    RSC_%s_METADATA_%s", fileid, metaData->name.c_str());
			fprintf (m_file, ",\n");
		}

		fprintf (m_file, "    RSC_%s_NBMETADATA\n", fileid);
		fprintf (m_file, "};\n\n");

        fprintf (m_file, "#define RSC_%s_MEDIAPRELOAD_SIZE %uUL\n\n", fileid, _mediausedsize);

		fprintf (m_file, "#ifndef %s_C\n", fileid);
		fprintf (m_file, "extern LOADdisk RSC_%s;\n", fileid);
		fprintf (m_file, "#endif\n\n");

		fprintf (m_file, "#endif\n");
    }
};


class LogFile : public OutputFile
{
public:
    LogFile(const char* _filename, const char* _fileid) 
        : OutputFile(_filename, "LOG", _fileid)
    {}

    void write(std::vector<FileEntry>& _fileEntries, std::vector<FileMetaData>& _metaData, u32 _imagesize, u32 _pos, u16 _preferedUnit)
    {
        int t = 0;
        assert (m_file != NULL);
        const char* fileid = m_fileid.c_str();


        fprintf (m_file, "LOG for %s\n\n", m_fileid.c_str());
        fprintf (m_file, "%d bytes left on floppy (%d bytes on %d)\n\n", _imagesize - _pos, _pos, _imagesize);

		fprintf (m_file, "FILE ENTRIES:\n\n"); 
		fprintf (m_file, "       nbSectors | @sector | @side | @track | metadata | lostbytes | roundsize | \n"); 

        for (std::vector<FileEntry>::const_iterator fileEntry = _fileEntries.begin() ; fileEntry != _fileEntries.end() ; fileEntry++)
		{
            fprintf (m_file, "%4d:  %9ld | %7ld | %5ld | %6ld | %8ld | %9d | %9d | %s\n",
                t++,
                fileEntry->nbsectors,
                fileEntry->startsector,
                fileEntry->side,
                fileEntry->track,
                fileEntry->metadataIndex,
                fileEntry->padding,
                fileEntry->nbsectors * LOAD_SECTORSIZE,
                fileEntry->name.c_str());
		}
		
        fprintf (m_file, "\n\n");

        fprintf (m_file, "METADATA ENTRIES:\n\n");
        fprintf (m_file, "       offset | size   | originalsize |\n");

        t = 0;

		for (std::vector<FileMetaData>::const_iterator metaData = _metaData.begin() ; metaData != _metaData.end() ; metaData++)
		{
            fprintf (m_file, "%4d:  %6d | %6d | %12d | %s\n", 
                t++,
                metaData->offset,
                metaData->size, 
                metaData->originalsize,
                metaData->name.c_str() );
		}

		fprintf (m_file, "\n\n");
    }
};


bool writeFAT(std::vector<FileEntry>& _fileEntries, std::vector<FileMetaData>& _metaData, FILE* _fileImage)
{
    u8 FAT[65536];
    u8* p = FAT;
    s32 fatsize = LOAD_SECTORSIZE * LOAD_FAT_NBSECTORS;


    memset (FAT, 0, sizeof(FAT));

    u16 nbFileEntries = (u16) _fileEntries.size();

    *(u16*) p = PCENDIANSWAP16(nbFileEntries);
    p += 2;

    u16 nbMetaDataEntries = (u16) _metaData.size();

    *(u16*) p = PCENDIANSWAP16(nbMetaDataEntries);
    p += 2;

    for (std::vector<FileEntry>::const_iterator fileEntry = _fileEntries.begin() ; fileEntry != _fileEntries.end() ; fileEntry++)
    {
        assert (fileEntry->side        < 2);
        assert (fileEntry->startsector <= LOAD_RESOURCE_MASK_STARTSECTOR);
        assert (fileEntry->nbsectors   <= LOAD_RESOURCE_MASK_NBSECTORS);

        // 1 bit side | 4 bits start sector | 11 bits nb sectors 
        // 9 bits metadataindex | 7 bits track num

        u16 startsectorsidenbsectors = (u16) ((fileEntry->side ? LOAD_RESOURCE_MASK_SIDE : 0) |
            (fileEntry->startsector << LOAD_RESOURCE_RSHIFT_STARTSECTOR) |
            fileEntry->nbsectors);

        *(u16*) p = PCENDIANSWAP16(startsectorsidenbsectors);
        p += 2;

        assert ((fileEntry->metadataIndex == -1) || (fileEntry->metadataIndex < LOAD_RESOURCE_NOMETADATA));
        assert (fileEntry->track <= LOAD_RESOURCE_MASK_TRACK);

        u16 metadatatracknum = (u16)((fileEntry->metadataIndex << LOAD_RESOURCE_RSHIFT_METADATA) | fileEntry->track);
        *(u16*) p = PCENDIANSWAP16(metadatatracknum);            
        p += 2;
    }

    for (std::vector<FileMetaData>::const_iterator metaData = _metaData.begin() ; metaData != _metaData.end() ; metaData++)
    {
        assert (metaData->offset       < (1 << (32 - LOAD_METADATA_RSHIFT_OFFSET)));
        assert (metaData->size         < (1 << (LOAD_METADATA_RSHIFT_OFFSET + LOAD_METADATA_RSHIFT_ORIGINALSIZE)));
        assert (metaData->originalsize < (1 << (32 - LOAD_METADATA_RSHIFT_ORIGINALSIZE))-1 );

        // 21 bits offset | 11 bits size high bits
        u32 offsetsizeh = (metaData->offset << LOAD_METADATA_RSHIFT_OFFSET) | (metaData->size >> LOAD_METADATA_LSHIFT_SIZEH);

        *(u32*) p = PCENDIANSWAP32(offsetsizeh);
        p += 4;

        // 21 bits original size | 11 bits size low bits 
        u32 originalsizesizel = (metaData->originalsize << LOAD_METADATA_RSHIFT_ORIGINALSIZE) | (metaData->size & LOAD_METADATA_MASK_SIZEL);

        *(u32*) p = PCENDIANSWAP32(originalsizesizel);
        p += 4;
    }

    printf ("FAT data size = %d\n", (p - FAT));

    if ( (p - FAT) > fatsize )
    {
        printf ("ERROR: FAT data exceeds %d bytes\n", fatsize);
        return false;
    }
    else
    {
        fseek (_fileImage, LOAD_SECTORSIZE * LOAD_FAT_STARTSECTOR, SEEK_SET);
        u32 result = fwrite (FAT, fatsize, 1, _fileImage);
        fseek (_fileImage, 0, SEEK_END);

        assert (result == 1);
        return true;
    }
}


static void makeId (char* _source, char* _dest)
{
	while (*_source)
	{
		if ((((*_source) >= 'A') && ((*_source) <= 'Z')) ||
			(((*_source) >= 'a') && ((*_source) <= 'z')) ||
			(((*_source) >= '0') && ((*_source) <= '9')))
		{
			*_dest = *_source;
		}
		else
		{
			*_dest = '_';
		}

		_source++;
		_dest++;
	}

	(*_dest) = 0;
}

struct FileType
{
    enum Enum
    {
        NORMAL,
        ARJ,
        BOOTSECTOR
    };
};

static void printPrgInfo (const char* _subdir, const char* _name)
{
    char temp[256];

    sprintf(temp, "%s%s%s%s", "DATABIN\\", _subdir, _name, ".PRG");

    FILE* file = fopen (temp, "rb");

    if ( file != NULL )
    {
        u32 value = 0;
        u32 total = 0;

        fseek(file, 2, SEEK_SET);

        printf ("Program file detected : %s\n", temp);

        fread (&value, sizeof(value), 1, file);
        value = PCENDIANSWAP32(value);
        printf ("text size:    %d\n", value);
        total += value;

        fread (&value, sizeof(value), 1, file);
        value = PCENDIANSWAP32(value);
        printf ("data size:    %d\n", value);
        total += value;

        fread (&value, sizeof(value), 1, file);
        value = PCENDIANSWAP32(value);
        printf ("bss size:     %d\n", value);
        total += value;

        fread (&value, sizeof(value), 1, file);
        value = PCENDIANSWAP32(value);
        printf ("symbols size: %d\n", value);
        total += value;

        printf ("total size:   %d bytes\n", total);

        fclose(file);
    }
}

static void* loadDataFile( const char* _currentName, u32& _filesize, s32& _originalsize, bool _executableBootSector)
{
    char filename[256];
    u8* buffer = NULL;

    sprintf (filename, "DATABIN\\%s", _currentName);
    
    {
        FILE* data = fopen (filename, "rb");

        if ( data == NULL )
        {
            printf ("ERROR: can not open file %s\n", filename);
            goto Error;
        }

        fseek (data, 0, SEEK_END);
        _filesize = ftell(data);
        fseek (data, 0, SEEK_SET);

        buffer = (u8*) malloc (_filesize);
        assert(buffer != NULL);

        u32 result = fread (buffer, 1, _filesize, data);
        assert(result == _filesize);
        fclose (data);
    }

    {
        char ext[256];
        char subdir[256];
        char name[256];

        _splitpath (_currentName, NULL, subdir, name, ext);

        printPrgInfo (subdir, name);

        FileType::Enum fileType = FileType::NORMAL;
    
        if ( _strcmpi(ext, ".ARJ") == 0 )
            fileType = FileType::ARJ;
        else if ( _strcmpi(ext, ".BOT") == 0 )
            fileType = FileType::BOOTSECTOR;
    
        if (fileType == FileType::ARJ)
        {
            printf ("ARJ file detected\n");

            if (( buffer[0] != 0x60 ) || ( buffer[1] != 0xEA ))
            {
                printf ("Error: '%s' is not an ARJ file\n", filename);
                goto Error;
            }
            else
            {
                u8* p = &buffer[2];
                
                u16 headerSize = *(u16*)p;
                p += sizeof(headerSize);
                p += headerSize;
                p += 4;     // skip crc

                u16 exHeaderSize = *(u16*)p;
                p += sizeof(exHeaderSize);

                if (exHeaderSize > 0)
                {
                    p += exHeaderSize;
                    p += 4;     // skip crc
                }

                if (( p[0] != 0x60 ) || ( p[1] != 0xEA ))
                {   
                    printf ("Error: '%s' is not an ARJ file\n", filename);
                    goto Error;  
                }

                p += 2;

                if ( p[7] != 4 )
                {
                    printf ("demOS expect to have ARJ file compressed in mode 4 (current is %d)\n", p[7]);
                }

                u32 compressedSize = *(u32*)&p[14];
                _originalsize = *(u32*)&p[18];

                printf ("sizes of ARJ : compressed=%d - uncompressed=%d (ratio=%d%%)\n", compressedSize, _originalsize, compressedSize * 100 / _originalsize);

                u16 localHeaderSize = *(u16*)p;
                p += sizeof(localHeaderSize);

                if (localHeaderSize > 0)
                {
                    p += localHeaderSize;
                    p += 4;     // skip crc
                }            

                u16 exLocalHeaderSize = *(u16*)p;
                p += sizeof(exLocalHeaderSize);

                if (exLocalHeaderSize > 0)
                {
                    p += localHeaderSize;
                    p += 4;     // skip crc
                }            

                u32 shrinkSize = p - buffer;

                shrinkSize -= 4; // leave place to store size

                printf ("image strip headers for %d bytes\n", shrinkSize);

                _filesize -= shrinkSize;
                memmove (&buffer[4], p, _filesize);

                *(u32*)buffer = STDswap32(_originalsize);
                {
                    sprintf (filename, "DATABIN\\%sX", _currentName);

                    FILE* data = fopen (filename, "wb");

                    if ( data == NULL )
                    {
                        printf ("ERROR: can not open file %s\n", filename);
                        goto Error;
                    }

                    u32 result = fwrite (buffer, 1, _filesize, data);
                    assert(result == _filesize);
                    fclose (data);
                }
            }
        }
        else if (fileType == FileType::BOOTSECTOR)
        {
            _filesize -= 28;
            memmove (buffer, buffer + 28, _filesize);
            _filesize -= 2;

            if (_filesize > LOAD_SECTORSIZE)
            {
                printf ("bootsector size exceeds %d bytes\n", LOAD_SECTORSIZE);
                goto Error;
            }

            if ( _executableBootSector )
            {
                u16 checksum = 0;

                _filesize -= 2;

                for (u32 t = 0 ; t < _filesize ; t += 2)
                {
                    checksum += STDswap16( *(u16*)&buffer[t] );
                }

                checksum = 0x1234 - checksum; 

                printf ("bootsector checksum diff 0x%x\n", checksum);

                memset (&buffer[_filesize], 0, LOAD_SECTORSIZE - _filesize);

                *(u16*)&buffer[LOAD_SECTORSIZE - 2] = STDswap16(checksum);
                _filesize = LOAD_SECTORSIZE;
            }
        }
    }

    return buffer;

Error:
    if ( buffer != NULL )
    {
        free (buffer);
    }

    return NULL;
}


bool writeST (char* _filename, u16 _nbSectorsPerTrack, u16 _nbsides, u16 _nbtracks, char** _filesList, u16 _preferedUnit, bool _executableBootSector)
{
	bool success = false;
	char filename[256];
    char fileid [256];

	u16 sides  = _nbsides - 1;
	u16 tracks = _nbtracks - 1;

    
    assert(LOAD_FAT_STARTSECTOR == 1);

	sprintf(filename, "%s.ST", _filename);
	FILE* fileImage = fopen (filename, "wb");

	makeId (_filename, fileid);

    HeaderFile  headerFile (_filename, fileid);
	LogFile     logFile    (_filename, fileid);

	if ( ( fileImage != NULL ) && headerFile.isValid() && logFile.isValid() )
	{
        fclose(fileImage);

        fileImage = fopen (filename, "rb+");
        assert(fileImage != NULL);

		char temp [4096];
		s32	 currentsector = 0;

        std::vector<FileEntry>    fileEntries;
        std::vector<FileMetaData> fileMetaData;
	
		while (*_filesList)
		{
            FileEntry fileEntry;
			char* s1 = *_filesList++;
			char* s2 = *_filesList++;
			char* filesToProcess;
			char* p;
			bool  singleFile;
			u32   size = 0;
            u16   metadataIndexBak = fileMetaData.size();

			makeId (s1, filename);
            fileEntry.name = filename;

			singleFile = s2 == NULL;
			filesToProcess = singleFile ? s1 : s2;

			strcpy (temp, filesToProcess);
			p = strtok (temp, ";");

			while (p != NULL)
			{
                u32 fsize = 0;
                s32 originalsize = LOAD_NOTPACKED;

                {
                    void* buffer = loadDataFile(p, fsize, originalsize, _executableBootSector );

                    if (buffer == NULL)
                    {
                        return false;
                    }

                    if (currentsector == 0)
                    {
                        if (fsize > LOAD_SECTORSIZE)
                        {
                            printf ("ERROR: expecting a boot sector file (%d > %d bytes) at beginning of disk => skip first sector\n", fsize, LOAD_SECTORSIZE);
                            return false;
                        }
                    }
                    else if (currentsector == LOAD_FAT_STARTSECTOR)
                    {
                        u8 data[LOAD_FAT_NBSECTORS * LOAD_SECTORSIZE];

                        printf ("reserving 2 sectors for FAT data\n");
                        memset (data, 0, sizeof(data));

                        u32 result = fwrite (data, 1, sizeof(data), fileImage);
                        assert(result == sizeof(data));

                        currentsector += LOAD_FAT_NBSECTORS;
                    }

                    printf ("write %s at %d\n", filename, ftell(fileImage));
                    u32 result = fwrite (buffer, 1, fsize, fileImage);
                    assert(result == fsize);

                    free(buffer);
                }

                sprintf (filename, "%s_%s", fileid, p);
                makeId (p, filename);

                {
                    FileMetaData metaData;

                    metaData.name         = filename;
                    metaData.filename     = p;
                    metaData.offset       = size;
                    metaData.size         = fsize;
                    metaData.originalsize = originalsize;

                    if (originalsize != LOAD_NOTPACKED )
                    {
                        metaData.filename += 'X';    
                        metaData.name     += 'X';

                        if (size == 0)
                        {
                            fileEntry.name += 'X';
                        }
                    }

                    fileMetaData.push_back(metaData);
                }

				size += fsize;
				p = strtok (NULL, ";");
			}

			u32 padding = (LOAD_SECTORSIZE - (size & 0x1FF)) & (LOAD_SECTORSIZE - 1);

			if ( padding > 0 )
			{
				memset(temp, 0, padding);
				fwrite (temp, 1, padding, fileImage);
			}
		
            u32 sector = currentsector % (_nbSectorsPerTrack * _nbsides);

            fileEntry.nbsectors     = (size + LOAD_SECTORSIZE - 1) / LOAD_SECTORSIZE;
            fileEntry.track         = currentsector / (_nbSectorsPerTrack * _nbsides);
            fileEntry.side          = sector >= _nbSectorsPerTrack;
            fileEntry.startsector   = sector % _nbSectorsPerTrack;
            fileEntry.padding       = padding;
            fileEntry.metadataIndex = metadataIndexBak;

            fileEntries.push_back(fileEntry);

            currentsector += fileEntry.nbsectors;
			if ( currentsector > (_nbSectorsPerTrack * _nbtracks * _nbsides ))
			{
				printf ("ERROR: size exceeds support with file %s\n", *(_filesList - 2));
				goto end;
			}
		}

        u32 imagesize = ((u32)_nbSectorsPerTrack * (u32)_nbsides * (u32)_nbtracks) * LOAD_SECTORSIZE;
        u32 pos = ftell(fileImage);

        if (pos <= imagesize)
        {
            u32 delta = imagesize - pos;

            void* buf = malloc (delta);
            assert (buf != NULL);
            memset (buf, 0, delta);
            fwrite (buf, delta, 1, fileImage);
            free(buf);

            headerFile.write(fileEntries, fileMetaData, pos);
            logFile.write(fileEntries, fileMetaData, imagesize, pos, _preferedUnit);
            
            success = writeFAT (fileEntries, fileMetaData, fileImage);
        }
	}

end:
	if ( fileImage != NULL )
	{
		fclose (fileImage);
	}

	return success;
}
