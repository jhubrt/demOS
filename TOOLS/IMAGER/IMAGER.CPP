/*-----------------------------------------------------------------------------------------------
  The MIT License (MIT)

  Copyright (c) 2015-2022 J.Hubert

  Permission is hereby granted, free of charge, to any person obtaining a copy of this software 
  and associated documentation files (the "Software"), 
  to deal in the Software without restriction, including without limitation the rights to use, 
  copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, 
  and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all copies 
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-------------------------------------------------------------------------------------------------*/

#define _CRT_SECURE_NO_WARNINGS
#include <assert.h>

#include "DEMOSDK\BASTYPES.H"

#include "TOOLS\IMAGER\IMAGER.H"

extern "C"
{
#   include "DEMOSDK\STANDARD.H"
#   include "DEMOSDK\LOAD.H"
#   include "DEMOSDK\LOADDEFS.H"
}

#include <vector>
#include <string>
#include <algorithm>

struct FileEntry
{
	u32	    nbsectors;
	u32     startsector;
	u32     side;
	u32     track;
    s32     metadataIndex;
    u32     padding;
    std::string name;
};

struct FileMetaData
{
	u32			offset;
	u32			size;
	s32			originalsize;
	std::string name;
    std::string filename;
};

class OutputFile
{
protected:
    FILE*           m_file;
    std::string     m_fileid;
    std::string     m_filename;


    OutputFile(const char* _sourcepath, const char* _filename, const char* _ext, const char* _fileid)
        : m_fileid      (_fileid)
        , m_filename    (_filename)
    {
    	char filename[256];
    	
        sprintf(filename, "%s%s.%s", _sourcepath, _filename, _ext);
	    m_file = fopen (filename, "w");
    }
    
    ~OutputFile()
    {
        if (m_file != NULL)
        {
            fclose(m_file);
            m_file = NULL;
        }
    }

public:
    
    bool isValid() const { return m_file != NULL; }
};


class HeaderFile : public OutputFile
{
public:
    HeaderFile (const char* _sourcepath, const char* _filename, const char* _fileid) 
        : OutputFile(_sourcepath, _filename, "H", _fileid)
  
    {}

    void write(std::vector<FileEntry>& _fileEntries, std::vector<FileMetaData>& _metaData)
    {
        assert (m_file != NULL);
        const char* fileid = m_fileid.c_str();

        fprintf (m_file, "/* This file is generated by Imager tool - it is synchronized with FAT data stored into sectors 1 & 2 */\n");

		fprintf (m_file, "#ifndef %s_H\n#define %s_H\n\n#include \"DEMOSDK\\LOAD.H\"\n\n", fileid, fileid);
		fprintf (m_file, "enum RSC_%s_ENTRIES\n{\n", fileid);

        for (u32 t = 0 ; t < _fileEntries.size() ; t++)
        {
			fprintf (m_file, "    RSC_%s_%s,\n", m_fileid.c_str(), _fileEntries[t].name.c_str() );
        }

		fprintf (m_file, "    RSC_%s_NBENTRIES\n", fileid);
        fprintf (m_file, "};\n\n");

		// Files metadata list

		fprintf (m_file, "enum RSC_%s_METADATA\n{\n", fileid);

		for (std::vector<FileMetaData>::const_iterator metaData = _metaData.begin() ; metaData != _metaData.end() ; metaData++)
		{
			fprintf (m_file, "    RSC_%s_METADATA_%s", fileid, metaData->name.c_str());
			fprintf (m_file, ",\n");
		}

		fprintf (m_file, "    RSC_%s_NBMETADATA\n", fileid);
		fprintf (m_file, "};\n\n");


		fprintf (m_file, "#ifndef %s_C\n", fileid);
		fprintf (m_file, "extern LOADdisk RSC_%s;\n", fileid);
		fprintf (m_file, "#endif\n\n");

		fprintf (m_file, "#endif\n");
    }
};


class LogFile : public OutputFile
{
public:
    LogFile(const char* _sourcepath, const char* _filename, const char* _fileid) 
        : OutputFile(_sourcepath, _filename, "TXT", _fileid)
    {}

    void write(std::vector<FileEntry>& _fileEntries, std::vector<FileMetaData>& _metaData, u32 _imagesize, u32 _pos, u16 _preferedUnit)
    {
        int t = 0;
        assert (m_file != NULL);
        const char* fileid = m_fileid.c_str();


        fprintf (m_file, "LOG for %s\n\n", m_fileid.c_str());
        fprintf (m_file, "%d bytes left on floppy (%d bytes on %d)\n\n", _imagesize - _pos, _pos, _imagesize);

		fprintf (m_file, "FILE ENTRIES:\n\n"); 
		fprintf (m_file, "       nbSectors | @sector | @side | @track | metadata | lostbytes | roundsize | \n"); 

        for (std::vector<FileEntry>::const_iterator fileEntry = _fileEntries.begin() ; fileEntry != _fileEntries.end() ; fileEntry++)
		{
            fprintf (m_file, "%4d:  %9ld | %7ld | %5ld | %6ld | %8ld | %9d | %9d | %s\n",
                t++,
                fileEntry->nbsectors,
                fileEntry->startsector,
                fileEntry->side,
                fileEntry->track,
                fileEntry->metadataIndex,
                fileEntry->padding,
                fileEntry->nbsectors * LOAD_SECTORSIZE,
                fileEntry->name.c_str());
		}
		
        fprintf (m_file, "\n\n");

        fprintf (m_file, "METADATA ENTRIES:\n\n");
        fprintf (m_file, "       offset | size   | originalsize |\n");

        t = 0;

		for (std::vector<FileMetaData>::const_iterator metaData = _metaData.begin() ; metaData != _metaData.end() ; metaData++)
		{
            fprintf (m_file, "%4d:  %6d | %6d | %12d | %s\n", 
                t++,
                metaData->offset,
                metaData->size, 
                metaData->originalsize,
                metaData->name.c_str() );
		}

		fprintf (m_file, "\n\n");
    }
};


bool writeFAT(std::vector<FileEntry>& _fileEntries, std::vector<FileMetaData>& _metaData, FILE* _fileImage, u32 _mediausedsize)
{
    u8 FAT[65536];
    u8* p = FAT;
    s32 fatsize = LOAD_SECTORSIZE * LOAD_FAT_NBSECTORS;


    memset (FAT, 0, sizeof(FAT));

    u16 nbFileEntries = (u16) _fileEntries.size();

    *(u16*) p = PCENDIANSWAP16(nbFileEntries);
    p += 2;

    u16 nbMetaDataEntries = (u16) _metaData.size();

    *(u16*) p = PCENDIANSWAP16(nbMetaDataEntries);
    p += 2;

    u16 preloadsizeshifted = (u16)((_mediausedsize + LOAD_MEDIAUSEDSIZE_SHIFT - 1) >> LOAD_MEDIAUSEDSIZE_SHIFT);
    *(u16*) p = PCENDIANSWAP16(preloadsizeshifted);
    p += 2;

    for (std::vector<FileEntry>::const_iterator fileEntry = _fileEntries.begin() ; fileEntry != _fileEntries.end() ; fileEntry++)
    {
        assert (fileEntry->side        < 2);
        assert (fileEntry->startsector <= LOAD_RESOURCE_MASK_STARTSECTOR);
        assert (fileEntry->nbsectors   <= LOAD_RESOURCE_MASK_NBSECTORS);

        // 1 bit side | 4 bits start sector | 11 bits nb sectors 
        // 9 bits metadataindex | 7 bits track num

        u16 startsectorsidenbsectors = (u16) ((fileEntry->side ? LOAD_RESOURCE_MASK_SIDE : 0) |
            (fileEntry->startsector << LOAD_RESOURCE_RSHIFT_STARTSECTOR) |
            fileEntry->nbsectors);

        *(u16*) p = PCENDIANSWAP16(startsectorsidenbsectors);
        p += 2;

        assert ((fileEntry->metadataIndex == -1) || (fileEntry->metadataIndex < LOAD_RESOURCE_NOMETADATA));
        assert (fileEntry->track <= LOAD_RESOURCE_MASK_TRACK);

        u16 metadatatracknum = (u16)((fileEntry->metadataIndex << LOAD_RESOURCE_RSHIFT_METADATA) | fileEntry->track);
        *(u16*) p = PCENDIANSWAP16(metadatatracknum);            
        p += 2;
    }

    for (std::vector<FileMetaData>::const_iterator metaData = _metaData.begin() ; metaData != _metaData.end() ; metaData++)
    {
        assert (metaData->offset       < (1 << (32 - LOAD_METADATA_RSHIFT_OFFSET)));
        assert (metaData->size         < (1 << (LOAD_METADATA_RSHIFT_OFFSET + LOAD_METADATA_RSHIFT_ORIGINALSIZE)));
        assert (metaData->originalsize < (1 << (32 - LOAD_METADATA_RSHIFT_ORIGINALSIZE))-1 );

        // 21 bits offset | 11 bits size high bits
        u32 offsetsizeh = (metaData->offset << LOAD_METADATA_RSHIFT_OFFSET) | (metaData->size >> LOAD_METADATA_LSHIFT_SIZEH);

        *(u32*) p = PCENDIANSWAP32(offsetsizeh);
        p += 4;

        // 21 bits original size | 11 bits size low bits 
        u32 originalsizesizel = (metaData->originalsize << LOAD_METADATA_RSHIFT_ORIGINALSIZE) | (metaData->size & LOAD_METADATA_MASK_SIZEL);

        *(u32*) p = PCENDIANSWAP32(originalsizesizel);
        p += 4;
    }

    printf ("FAT data size = %d\n", (p - FAT));

    if ( (p - FAT) > fatsize )
    {
        printf ("ERROR: FAT data exceeds %d bytes\n", fatsize);
        return false;
    }
    else
    {
        fseek (_fileImage, LOAD_SECTORSIZE * LOAD_FAT_STARTSECTOR, SEEK_SET);
        u32 result = fwrite (FAT, fatsize, 1, _fileImage);
        fseek (_fileImage, 0, SEEK_END);

        assert (result == 1);
        return true;
    }
}


static void makeId (const char* _source, char* _dest)
{
	while (*_source)
	{
		if ((((*_source) >= 'A') && ((*_source) <= 'Z')) ||
			(((*_source) >= 'a') && ((*_source) <= 'z')) ||
			(((*_source) >= '0') && ((*_source) <= '9')))
		{
			*_dest = *_source;
		}
		else
		{
			*_dest = '_';
		}

		_source++;
		_dest++;
	}

	(*_dest) = 0;
}

struct FileType
{
    enum Enum
    {
        NORMAL,
        ARJX,
        BOOTSECTOR
    };
};

static void printPrgInfo (const char* _subdir, const char* _name)
{
    char temp[256];

    sprintf(temp, "%s%s%s%s", "DATABIN\\", _subdir, _name, ".PRG");

    FILE* file = fopen (temp, "rb");

    if ( file != NULL )
    {
        u32 value = 0;
        u32 total = 0;

        fseek(file, 2, SEEK_SET);

        printf ("Program file detected : %s\n", temp);

        fread (&value, sizeof(value), 1, file);
        value = PCENDIANSWAP32(value);
        printf ("text size:    %d\n", value);
        total += value;

        fread (&value, sizeof(value), 1, file);
        value = PCENDIANSWAP32(value);
        printf ("data size:    %d\n", value);
        total += value;

        fread (&value, sizeof(value), 1, file);
        value = PCENDIANSWAP32(value);
        printf ("bss size:     %d\n", value);
        total += value;

        fread (&value, sizeof(value), 1, file);
        value = PCENDIANSWAP32(value);
        printf ("symbols size: %d\n", value);
        total += value;

        printf ("total size:   %d bytes\n", total);

        fclose(file);
    }
}

static void* loadDataFile(const char* _sourcepath, const char* _currentName, u32& _filesize, s32& _originalsize, bool _executableBootSector)
{
    char filename[256];
    u8* buffer = NULL;

    sprintf (filename, "%s\\DATABIN\\%s", _sourcepath, _currentName);
    
    {
        FILE* data = fopen (filename, "rb");

        if ( data == NULL )
        {
            printf ("ERROR: can not open file %s\n", filename);
            goto Error;
        }

        fseek (data, 0, SEEK_END);
        _filesize = ftell(data);
        fseek (data, 0, SEEK_SET);

        u32 allocsize = std::max<u32>(_filesize, LOAD_SECTORSIZE);

        buffer = (u8*) malloc (allocsize);
        assert(buffer != NULL);

        u32 result = fread (buffer, 1, _filesize, data);
        assert(result == _filesize);
        fclose (data);
    }

    {
        char ext[256];
        char subdir[256];
        char name[256];

        _splitpath (_currentName, NULL, subdir, name, ext);

        printPrgInfo (subdir, name);

        FileType::Enum fileType = FileType::NORMAL;
    
        if ( _strcmpi(ext, ".ARJX") == 0 )
            fileType = FileType::ARJX;
        else if ( _strcmpi(ext, ".BOT") == 0 )
            fileType = FileType::BOOTSECTOR;
    
        if (fileType == FileType::ARJX)
        {
            _originalsize = STDswap32(*(u32*)buffer);
            printf("ARJX file detected - sizes: compressed=%d - uncompressed=%d (ratio=%d%%)\n", _filesize, _originalsize, _filesize * 100 / _originalsize);
        }
        else if (fileType == FileType::BOOTSECTOR)
        {
            _filesize -= 28;
            memmove (buffer, buffer + 28, _filesize);
            _filesize -= 2;

            if (_filesize > LOAD_SECTORSIZE)
            {
                printf ("bootsector size exceeds %d bytes\n", LOAD_SECTORSIZE);
                goto Error;
            }

            if ( _executableBootSector )
            {
                u16 checksum = 0;

                _filesize -= 2;

                for (u32 t = 0 ; t < _filesize ; t += 2)
                {
                    checksum += STDswap16( *(u16*)&buffer[t] );
                }

                checksum = 0x1234 - checksum; 

                printf ("bootsector checksum diff 0x%x\n", checksum);

                memset (&buffer[_filesize], 0, LOAD_SECTORSIZE - _filesize);

                *(u16*)&buffer[LOAD_SECTORSIZE - 2] = STDswap16(checksum);
                _filesize = LOAD_SECTORSIZE;
            }
        }
    }

    return buffer;

Error:
    if ( buffer != NULL )
    {
        free (buffer);
    }

    return NULL;
}


bool writeST (const char* _sourcepath, const char* _imagepath, const char* _imagename, u16 _nbSectorsPerTrack, u16 _nbsides, u16 _nbtracks, u16 _preferedUnit, bool _executableBootSector, const char** _filesList)
{
	bool success = false;
	char filename[256];
    char fileid [256];

	u16 sides  = _nbsides - 1;
	u16 tracks = _nbtracks - 1;

    
    assert(LOAD_FAT_STARTSECTOR == 1);

	sprintf(filename, "%s%s.ST", _imagepath, _imagename);
	FILE* fileImage = fopen (filename, "wb");

	makeId (_imagename, fileid);

    HeaderFile  headerFile (_sourcepath, _imagename, fileid);
	LogFile     logFile    (_sourcepath, _imagename, fileid);

	if ( ( fileImage != NULL ) && headerFile.isValid() && logFile.isValid() )
	{
        fclose(fileImage);

        fileImage = fopen (filename, "rb+");
        assert(fileImage != NULL);

		char temp [4096];
		s32	 currentsector = 0;

        std::vector<FileEntry>    fileEntries;
        std::vector<FileMetaData> fileMetaData;
	
		while (*_filesList)
		{
            FileEntry fileEntry;
			const char* s1 = *_filesList++;
			const char* s2 = *_filesList++;
			const char* filesToProcess;
			char* p;
			bool  singleFile;
			u32   size = 0;
            u16   metadataIndexBak = static_cast<u16>(fileMetaData.size());

			makeId (s1, filename);
            fileEntry.name = filename;

			singleFile = s2 == NULL;
			filesToProcess = singleFile ? s1 : s2;

			strcpy (temp, filesToProcess);
			p = strtok (temp, ";");

			while (p != NULL)
			{
                u32 fsize = 0;
                s32 originalsize = LOAD_NOTPACKED;
                u32 filepadding = 0;

                {
                    void* buffer = loadDataFile(_sourcepath, p, fsize, originalsize, _executableBootSector);

                    if (buffer == NULL)
                    {
                        return false;
                    }

                    if (currentsector == 0)
                    {
                        if (fsize > LOAD_SECTORSIZE)
                        {
                            printf ("ERROR: expecting a boot sector file (%d > %d bytes) at beginning of disk => skip first sector\n", fsize, LOAD_SECTORSIZE);
                            return false;
                        }
                    }
                    else if (currentsector == LOAD_FAT_STARTSECTOR)
                    {
                        u8 data[LOAD_FAT_NBSECTORS * LOAD_SECTORSIZE];

                        printf ("reserving 2 sectors for FAT data\n");
                        memset (data, 0, sizeof(data));

                        u32 result = fwrite (data, 1, sizeof(data), fileImage);
                        assert(result == sizeof(data));

                        currentsector += LOAD_FAT_NBSECTORS;
                    }

                    printf ("write %s at %d\n", filename, ftell(fileImage));
                    u32 result = fwrite (buffer, 1, fsize, fileImage);
                    assert(result == fsize);
                    filepadding = fsize & 1;
                    if (filepadding)
                    {
                        u8 val = 0;
                        result = fwrite (&val, 1, 1, fileImage);
                        assert(result == 1);
                    }

                    free(buffer);
                }

                sprintf (filename, "%s_%s", fileid, p);
                makeId (p, filename);

                {
                    FileMetaData metaData;

                    metaData.name         = filename;
                    metaData.filename     = p;
                    metaData.offset       = size;
                    metaData.size         = fsize;
                    metaData.originalsize = originalsize;

                    fileMetaData.push_back(metaData);
                }

				size += fsize + filepadding;
				p = strtok (NULL, ";");
			}

			u32 padding = (LOAD_SECTORSIZE - (size & 0x1FF)) & (LOAD_SECTORSIZE - 1);

			if ( padding > 0 )
			{
				memset(temp, 0, padding);
				fwrite (temp, 1, padding, fileImage);
			}
		
            u32 sector = currentsector % (_nbSectorsPerTrack * _nbsides);

            fileEntry.nbsectors     = (size + LOAD_SECTORSIZE - 1) / LOAD_SECTORSIZE;
            fileEntry.track         = currentsector / (_nbSectorsPerTrack * _nbsides);
            fileEntry.side          = sector >= _nbSectorsPerTrack;
            fileEntry.startsector   = sector % _nbSectorsPerTrack;
            fileEntry.padding       = padding;
            fileEntry.metadataIndex = metadataIndexBak;

            fileEntries.push_back(fileEntry);

            currentsector += fileEntry.nbsectors;
			if ( currentsector > (_nbSectorsPerTrack * _nbtracks * _nbsides ))
			{
				printf ("ERROR: size exceeds support with file %s\n", *(_filesList - 2));
				goto end;
			}
		}

        u32 imagesize = ((u32)_nbSectorsPerTrack * (u32)_nbsides * (u32)_nbtracks) * LOAD_SECTORSIZE;
        u32 pos = ftell(fileImage);

        if (pos <= imagesize)
        {
            u32 delta = imagesize - pos;

            void* buf = malloc (delta);
            assert (buf != NULL);
            memset (buf, 0, delta);
            fwrite (buf, delta, 1, fileImage);
            free(buf);

            headerFile.write(fileEntries, fileMetaData);
            logFile.write(fileEntries, fileMetaData, imagesize, pos, _preferedUnit);
            
            success = writeFAT (fileEntries, fileMetaData, fileImage, pos);
        }
	}

end:
	if ( fileImage != NULL )
	{
		fclose (fileImage);
	}

	return success;
}
